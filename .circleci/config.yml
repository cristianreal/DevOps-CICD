version: 2.1
jobs:
  test:
    machine:
      image: ubuntu-1604:201903-01
    steps:
      - checkout
      - run:
          name: "Tests backend"
          command: |
            cd ${HOME}/project/code/backend
            docker build -t christianreal/backend-nodejs:${CIRCLE_SHA1} .
            docker run --name service-nodejs --env-file env.list -p 5000:5000 -d christianreal/backend-nodejs:${CIRCLE_SHA1}
            docker exec -it service-nodejs npm test
      - run:
          name: "Test Frontend"
          command: |
            cd ${HOME}/project/code/client
            docker build -t christianreal/frontend-vuejs:test1${CIRCLE_SHA1} -f Dockerfile.test . 
  continous_integration_delivery:
    machine:
      image: ubuntu-1604:201903-01
    steps:
      - checkout
      - run:
          name: "Build Image Backend"
          command: |
            cd ${HOME}/project/code/backend
            docker build -t christianreal/backend-nodejs:${CIRCLE_SHA1} . 
      - run:
          name: "Build Image Frontend"
          command: |
            cd ${HOME}/project/code/client
            docker build -t christianreal/frontend-vuejs:${CIRCLE_SHA1} . 
      - run:
          name: "Test Backend"
          command: |
            cd ${HOME}/project/code/backend
            docker run --name service-nodejs --env-file env.list -p 5000:5000 -d christianreal/backend-nodejs:${CIRCLE_SHA1}
            docker exec -it service-nodejs npm test 
      - run:
          name: "Push images to registry"
          command: |
            echo "$DOCKERHUB_PASS" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
            docker push christianreal/backend-nodejs:${CIRCLE_SHA1}
            docker push christianreal/frontend-vuejs:${CIRCLE_SHA1}
  continous_deployment:
    docker: 
      - image: google/cloud-sdk    
    steps:      
      - checkout
      - run:          
          name: Auth gCloud SDK 
          command: |
            #!/bin/sh
            set -e
            echo ${CREDENTIALS} > ${HOME}/gcp-key.json
            gcloud auth activate-service-account --key-file ${HOME}/gcp-key.json
            gcloud --quiet config set project ${PROJECT_ID}
            gcloud config set compute/zone ${GOOGLE_COMPUTE_ZONE}
      - run:          
          name: Apply kubernetes files to the cluster
          command: |
            for cluster in  $(gcloud container clusters list --project ${PROJECT_ID} --filter devops-ci-cd --format="value(selfLink.scope(clusters))")
            do
              export CLUSTER=$cluster
            done
            gcloud container clusters get-credentials ${CLUSTER} --zone ${GOOGLE_COMPUTE_ZONE} --project ${PROJECT_ID}
            kubectl apply -f deployment/K8/deployments
            kubectl set image deployment/deployment-nodejs nodejs-container=christianreal/backend-nodejs:${CIRCLE_SHA1} --record
            kubectl set image deployment/deployment-vuejs vuejs-container=christianreal/frontend-vuejs:${CIRCLE_SHA1} --record
            kubectl apply -f deployment/K8/services/clusterip
            kubectl apply -f deployment/K8/services/service-ingress.yml 
  infrastructure_deployment:
    machine:
      image: ubuntu-1604:201903-01
    steps:
      - checkout
      - run:
          name: "Instalar terraform & Crear archivo de credenciales."  
          command: |
            sudo bash deployment/Terraform/script.sh
            echo ${CREDENTIALS} > ${HOME}/gcloud-key.json
      - run:
          name: "Desplegar infraestructura con terraform"
          command: |
            cd deployment/Terraform
            export GOOGLE_APPLICATION_CREDENTIALS=${HOME}/gcloud-key.json
            export TF_VAR_project_id=${PROJECT_ID}
            export TF_VAR_db_username=${DB_USERNAME}
            export TF_VAR_db_password=${DB_PASSWORD}
            terraform init 
            terraform plan -out plan.out
            terraform apply plan.out
  configure_infrastructure:
    docker: 
      - image: google/cloud-sdk    
    steps:      
      - checkout
      - run:          
          name: Autenticar gCloud SDK 
          command: |
            #!/bin/sh
            set -e
            echo ${CREDENTIALS} > ${HOME}/gcp-key.json
            gcloud auth activate-service-account --key-file ${HOME}/gcp-key.json
            gcloud --quiet config set project ${PROJECT_ID}
            gcloud config set compute/zone ${GOOGLE_COMPUTE_ZONE}
      - run:          
          name: Autenticar en el GKE cluster.
          command: |
            export CLUSTER=$(gcloud container clusters list --project ${PROJECT_ID} --filter devops-ci-cd --format="value(selfLink.scope(clusters))" --limit=1)
            gcloud container clusters get-credentials ${CLUSTER} --zone ${GOOGLE_COMPUTE_ZONE} --project ${PROJECT_ID}
      - run:          
          name: Instalar y averiguar la IP de ingress-controller, si no existe esperara hasta que se aprovisione.
          command: |      
            export ip=$(kubectl get svc --namespace ingress-nginx ingress-nginx-controller  --template="{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}" --ignore-not-found);
            if  [ -z "$ip" ]
            then
                kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml
                external_ip=""; while [ -z $external_ip ]; do echo "Waiting for end point..."; external_ip=$(kubectl get svc --namespace ingress-nginx ingress-nginx-controller  --template="{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}" --ignore-not-found); [ -z "$external_ip" ] && sleep 10; done; echo "End point ready-" && echo $external_ip; export endpoint=$external_ip
                export DB_IP=$(gcloud sql instances list --project ${PROJECT_ID} --filter db-instance --format="value(PRIMARY_ADDRESS)" --limit=1)
                # Ejecuta el script incial en la DB para crear las tablas y datos default.
                export DB_NAME=$(gcloud sql instances list --project ${PROJECT_ID} --filter db-instance --format="value(NAME)" --limit=1)
                gcloud sql import sql ${DB_NAME}  gs://backend-terraform-devops-ci-cd/db/filename.sql -q
                
                # Crear registros en la zona DNS para la base de datos e ingress controller
                    gcloud dns record-sets import -z zona --delete-all-existing /dev/null --project ${PROJECT_ID}
                    gcloud dns record-sets transaction start --zone=zona --project ${PROJECT_ID}
                    gcloud dns record-sets transaction add ${endpoint} --name=poliformas.com.gt. --ttl=300 --type=A --zone=zona
                    gcloud dns record-sets transaction add "poliformas.com.gt." --name="www.poliformas.com.gt." --ttl=300 --type=CNAME --zone=zona
                    gcloud dns record-sets transaction add ${DB_IP} --name=db.poliformas.com.gt. --ttl=300 --type=A --zone=zona
                    gcloud dns record-sets transaction execute --zone=zona --project ${PROJECT_ID}
                
                # Instalar certificados SSL en el ingress-controller utiliando helm
                    curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
                    chmod 700 get_helm.sh
                    ./get_helm.sh
                    helm repo add jetstack https://charts.jetstack.io
                    kubectl create namespace cert-manager
                    kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.14.1/cert-manager.crds.yaml
                    kubectl apply -f deployment/K8/services/letsencrypt-prod.yaml
                    kubectl apply -f deployment/K8/configmaps/
                    kubectl apply -f deployment/K8/secrets/
                    helm install cert-manager --namespace cert-manager jetstack/cert-manager --version v0.14.1
            fi
workflows:
  version: 2
  pipeline-principal:
    jobs:
      - test:
          filters:
              branches:
                only:
                  - developer
      - continous_integration_delivery:
          filters:
              branches:
                only:
                  - master
      - continous_deployment:
          requires:
            - continous_integration_delivery
          filters:
              branches:
                only:
                  - master
      - infrastructure_deployment:
          filters:
              branches:
                only:
                  - infrastructure
      - configure_infrastructure:
          requires:
            - infrastructure_deployment
          filters:
              branches:
                only:
                  - infrastructure